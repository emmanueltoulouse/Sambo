/* MainWindow.vala
 *
 * Copyright 3
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

using Gtk;
using Adw;

namespace IntaText {
    public class MainWindow : Adw.ApplicationWindow {
        private ApplicationController controller;

        // En-têtes des principales sections
        private Adw.HeaderBar header_bar;

        // Contenu principal de la fenêtre
        private Box main_box;
        private Paned main_paned;

        // Les trois vues principales
        private ExplorerView explorer_view;
        private CommunicationView communication_view;
        private Paned editor_comm_paned;
        private Paned top_paned;

        // Ajouter une variable privée
        private bool use_detached_explorer = false;

        // Ajouter ces signaux en haut de la classe MainWindow
        public signal void file_opened(string path);
        public signal void directory_changed(string path);

        // Ajouter avec les autres variables d'instance en haut de la classe
        private ToggleButton explorer_button;
        private ToggleButton communication_button; // Si cette variable n'existe pas déjà

        // 1. Déclare un Notebook et une liste d'éditeurs
        private Notebook editor_notebook;
        private Gee.List<EditorView> editor_tabs = new Gee.ArrayList<EditorView>();

        // Constructeur amélioré
        public MainWindow(Gtk.Application app, ApplicationController controller, bool detached_explorer_mode = false) {
            Object(
                application: app,
                title: "IntaText",
                width_request: 1200, // Largeur initiale augmentée
                height_request: 600,
                default_width: 1200, // Largeur minimale pour la barre d'icônes
                default_height: 600,
                resizable: true
            );
            this.set_size_request(1200, 450); // Largeur et hauteur minimales effectives

            this.controller = controller;
            this.use_detached_explorer = detached_explorer_mode;

            print("TRACE: MainWindow CONSTRUCTEUR - use_detached_explorer=%s\n", use_detached_explorer ? "OUI" : "NON");

            setup_ui();
            setup_actions();
            connect_signals();

            // Restaurer les dimensions au chargement
            this.map.connect(() => {
                Timeout.add(100, () => {
                    restore_window_state();
                    return false;
                });
            });
        }

        /**
         * Initialise l'interface utilisateur
         */
        private void setup_ui() {
            print("TRACE: setup_ui() - Début - this.explorer_view=%p\n", this.explorer_view);

            // Créer la structure principale de la fenêtre
            main_box = new Box(Orientation.VERTICAL, 0);

            // --- Barre de titre ---
            header_bar = new Adw.HeaderBar();
            // (Le code pour ajouter les boutons open, search, menu, explorer, communication, test_save reste identique)
            // ... Ajout des boutons à header_bar ...
            /*
            var open_button = new Button.from_icon_name("document-open-symbolic");
            open_button.set_tooltip_text("Ouvrir un fichier");
            open_button.set_action_name("win.open-file");
            header_bar.pack_start(open_button);
            */

            var menu_button = new MenuButton();
            menu_button.set_icon_name("open-menu-symbolic");
            menu_button.set_tooltip_text("Menu principal");
            menu_button.set_menu_model(build_app_menu());
            header_bar.pack_end(menu_button);

            explorer_button = new ToggleButton();
            explorer_button.set_icon_name("folder-symbolic");
            explorer_button.set_tooltip_text(_("Afficher/Masquer l'explorateur"));
            explorer_button.set_active(true); // Sera ajusté par restore_window_state
            explorer_button.toggled.connect((button) => {
                controller.toggle_explorer_visibility(button.get_active());
            });
            // Le bouton est toujours visible, il contrôle soit l'intégré soit le détaché
            header_bar.pack_end(explorer_button);

            communication_button = new ToggleButton();
            communication_button.set_icon_name("mail-message-new-symbolic");
            communication_button.set_tooltip_text("Afficher/Masquer la zone de communication");
            communication_button.set_active(true); // Sera ajusté par restore_window_state
            header_bar.pack_end(communication_button);

            // Bouton de test (à retirer)
            var test_save = new Button.with_label("TEST");
            test_save.clicked.connect(() => { save_window_state(); });
            header_bar.pack_end(test_save);

            main_box.append(header_bar);

            // --- Panneau principal et Vues ---
            main_paned = new Paned(Orientation.VERTICAL);
            main_paned.set_vexpand(true);
            main_paned.set_wide_handle(true);

            print("TRACE: setup_ui() - Vérification condition - use_detached_explorer = %s\n", use_detached_explorer ? "OUI" : "NON");

            if (use_detached_explorer) {
                // --- Mode Détaché ---
                print("TRACE: setup_ui() - MODE DETACHE - AVANT mise à NULL - explorer_view=%p\n", explorer_view);

                // S'assurer que ces vues ne sont PAS créées ou utilisées en mode détaché
                explorer_view = null;
                top_paned = null;

                print("TRACE: setup_ui() - MODE DETACHE - APRÈS mise à NULL - explorer_view=%p\n", explorer_view);

                // Ajouter directement l'éditeur comme enfant supérieur
                editor_notebook = new Notebook();
                main_box.append(editor_notebook);

                // Ajouter la vue communication comme enfant inférieur
                communication_view = new CommunicationView(controller);
                main_paned.set_end_child(communication_view);

                // Référence pour le toggle communication
                editor_comm_paned = main_paned;

            } else {
                // --- Mode Intégré ---
                print("TRACE: setup_ui() - MODE INTEGRE - Création ExplorerView\n");

                // Créer le panneau horizontal supérieur (UNIQUEMENT ICI)
                top_paned = new Paned(Orientation.HORIZONTAL);
                top_paned.set_wide_handle(true);
                top_paned.set_vexpand(true);

                // Vue explorateur à gauche (CRÉÉE ICI UNIQUEMENT)
                var explorer_model = ApplicationControllerExtension.get_explorer_model(controller);
                explorer_view = new ExplorerView(explorer_model); // Création
                print("TRACE: setup_ui() - ExplorerView créé à l'adresse %p\n", explorer_view);
                explorer_view.set_size_request(200, -1);
                top_paned.set_start_child(explorer_view); // Ajout au panneau sup

                // Vue éditeur à droite
                editor_notebook = new Notebook();
                top_paned.set_end_child(editor_notebook); // Ajout au panneau sup

                // Placer ce panneau sup en haut du panneau principal (UNIQUEMENT ICI)
                main_paned.set_start_child(top_paned);

                // Vue communication en bas
                communication_view = new CommunicationView(controller);
                communication_view.set_size_request(-1, 150);
                main_paned.set_end_child(communication_view); // Ajout au panneau principal

                // Configuration des séparateurs
                main_paned.set_resize_start_child(false);
                main_paned.set_shrink_start_child(false);
                main_paned.set_resize_end_child(false);
                main_paned.set_shrink_end_child(false);
                top_paned.set_resize_start_child(false);
                top_paned.set_shrink_start_child(false);

                // Positions initiales (seront ajustées par restore_window_state)
                top_paned.set_position(280);
                main_paned.set_position(500);

                // Référence pour le toggle communication
                editor_comm_paned = main_paned;
            }

            // Ajouter le panneau principal (configuré pour intégré ou détaché) à la boîte principale
            main_box.append(main_paned);

            // Définir le contenu de la fenêtre
            set_content(main_box);

            print("TRACE: setup_ui() - Fin - this.explorer_view=%p\n", this.explorer_view);

            // --- FIN DE LA LOGIQUE DE CRÉATION CONDITIONNELLE ---
            // Les blocs redondants ont été supprimés.

            // Appel final pour connecter les signaux après que tout est construit
            // Seulement si l'explorateur est intégré dans cette fenêtre
            if (explorer_view != null) {
                print("TRACE: setup_ui() - Appel de connect_explorer_signals sur explorer_view=%p\n", explorer_view);
                // TODO: Assurez-vous que la méthode connect_explorer_signals existe dans ApplicationController ou une extension.
                // controller.connect_explorer_signals(); // Temporairement commenté si la méthode n'existe pas encore
            }

            // Créer un onglet vide par défaut au démarrage avec bouton de fermeture
            var default_editor = new EditorView(controller);
            editor_tabs.add(default_editor);

            // Créer un widget personnalisé pour l'onglet par défaut avec bouton de fermeture
            var default_tab_box = new Box(Orientation.HORIZONTAL, 6);
            var default_label = new Label(_("Nouveau document"));
            var default_close_button = new Button.from_icon_name("window-close-symbolic");
            default_close_button.add_css_class("flat");
            default_close_button.add_css_class("circular");
            default_close_button.set_tooltip_text(_("Fermer"));
            default_close_button.set_valign(Align.CENTER);
            default_tab_box.append(default_label);
            default_tab_box.append(default_close_button);
            default_tab_box.show();

            // Ajouter avec les mêmes propriétés que les autres onglets
            editor_notebook.append_page(default_editor, default_tab_box);
            editor_notebook.set_tab_reorderable(default_editor, true);
            editor_notebook.set_current_page(0);

            // Connecter le signal du bouton de fermeture
            default_close_button.clicked.connect(() => {
                close_tab(default_editor);
            });

            print("TRACE: setup_ui() - Onglet par défaut créé avec bouton de fermeture\n");
        }

        /**
         * Configure les actions de la fenêtre
         */
        private void setup_actions() {
            /*
            // Action pour ouvrir un fichier
            var open_action = new SimpleAction("open-file", null);
            open_action.activate.connect(() => {
                // Remplacer FileChooserDialog (déprécié) par FileDialog de GTK4
                var open_dialog = new FileDialog();
                open_dialog.set_title(_("Ouvrir un fichier"));

                // ... (code pour les filtres) ...
                var filter = new FileFilter();
                filter.add_mime_type("text/plain");
                filter.add_mime_type("text/markdown");
                filter.add_mime_type("text/html");
                filter.add_pattern("*.txt");
                filter.add_pattern("*.md");
                filter.add_pattern("*.html");
                var filters = new GLib.ListStore(typeof(FileFilter));
                filters.append(filter);
                open_dialog.set_filters(filters);


                // Utiliser open() au lieu de run()
                open_dialog.open.begin(this, null, (obj, res) => {
                    try {
                        var file = open_dialog.open.end(res);
                        if (file != null) {
                            // CORRECTION: Appeler la logique pivot du contrôleur
                            controller.handle_file_open_request(file.get_path());
                            // SUPPRIMER l'ancien appel à navigate_to:
                            // var explorer_model = ApplicationControllerExtension.get_explorer_model(controller);
                            // if (explorer_model != null) {
                            //     explorer_model.navigate_to(file.get_path());
                            // }
                        }
                    } catch (Error e) {
                        warning("Erreur lors de l'ouverture du fichier via dialogue: %s", e.message);
                    }
                });
            });
            */

            // ... (autres actions: search, quit, preferences, about) ...
            // Action pour quitter l'application
            var quit_action = new SimpleAction("quit", null);
            quit_action.activate.connect(() => {
                // Montrer une confirmation avant de quitter si nécessaire
                if (should_confirm_quit()) {
                    // Remplacer MessageDialog par AlertDialog
                    var dialog = new Adw.AlertDialog(
                        _("Quitter l'application"),
                        _("Êtes-vous sûr de vouloir quitter ? Les modifications non enregistrées seront perdues.")
                    );

                    dialog.add_response("cancel", _("Annuler"));
                    dialog.add_response("quit", _("Quitter"));
                    dialog.set_response_appearance("quit", Adw.ResponseAppearance.DESTRUCTIVE);

                    dialog.response.connect((response) => {
                        if (response == "quit") {
                            // Sauvegarder la configuration
                            save_window_state();
                            // Fermer l'application
                            application.quit();
                        }
                    });

                    dialog.present(this);
                } else {
                    // Pas besoin de confirmation, quitter directement
                    save_window_state();
                    application.quit();
                }
            });

            // Action pour les préférences
            var preferences_action = new SimpleAction("preferences", null);
            preferences_action.activate.connect(() => {
                var prefs_window = new PreferencesWindow(controller);
                prefs_window.present();
            });
            add_action(preferences_action);

            // Action pour afficher À propos
            var about_action = new SimpleAction("about", null);
            about_action.activate.connect(() => {
                // Utiliser About.Dialog à la place de Adw.AboutWindow qui est déprécié
                var about = new Gtk.AboutDialog() {
                    transient_for = this,
                    program_name = "IntaText",
                    logo_icon_name = "com.cabineteto.IntaText",
                    version = "0.1.0",
                    authors = { "Cabinet ETO" },
                    copyright = "© 2023 Cabinet ETO",
                    license_type = Gtk.License.GPL_3_0,
                    website = "https://cabineteto.com",
                    website_label = _("Site Web")
                };

                // Présenter sans argument car present() ne prend pas d'argument
                about.present();
            });

            // Ajouter toutes les actions à la fenêtre
            // add_action(open_action);
            add_action(quit_action);
            add_action(preferences_action);
            add_action(about_action);

            // Ajouter des raccourcis clavier
            // application.set_accels_for_action("win.open-file", {"<Control>o"});
            application.set_accels_for_action("win.quit", {"<Control>q"});
            application.set_accels_for_action("win.preferences", {"<Control>comma"});

            // Action pour sauvegarder un fichier
            var save_action = new SimpleAction("save-file", null);
            save_action.activate.connect(() => {
                save_current_document();
            });
            this.add_action(save_action);

            // Action pour sauvegarder sous un nouveau nom
            var save_as_action = new SimpleAction("save-file-as", null);
            save_as_action.activate.connect(() => {
                save_current_document_as();
            });
            this.add_action(save_as_action);

            // Ajouter des raccourcis clavier pour la sauvegarde
            application.set_accels_for_action("win.save-file", {"<Control>s"});
            application.set_accels_for_action("win.save-file-as", {"<Control><Shift>s"});
        }

        /**
         * Construction du menu principal
         */
        private GLib.MenuModel build_app_menu() {
            var menu = new GLib.Menu();

            // Menu Fichier
            var file_menu = new GLib.Menu();
            file_menu.append(_("Nouveau"), "win.new-file");
            file_menu.append(_("Ouvrir..."), "win.open-file");
            file_menu.append(_("Enregistrer"), "win.save-file");
            file_menu.append(_("Enregistrer sous..."), "win.save-file-as");
            file_menu.append(_("Fermer"), "win.close-file");
            file_menu.append(_("Quitter"), "win.quit");

            // Menu Édition
            var edit_menu = new GLib.Menu();
            edit_menu.append(_("Annuler"), "win.undo");
            edit_menu.append(_("Rétablir"), "win.redo");
            edit_menu.append(_("Couper"), "win.cut");
            edit_menu.append(_("Copier"), "win.copy");
            edit_menu.append(_("Coller"), "win.paste");

            // Menu Affichage
            var view_menu = new GLib.Menu();
            view_menu.append(_("Plein écran"), "win.fullscreen");
            view_menu.append(_("Mode sombre"), "win.dark-mode");

            // Menu Outils - MODIFICATION ICI
            var tools_menu = new GLib.Menu();
            tools_menu.append(_("Préférences"), "win.preferences");  // Déplacé du menu Aide
            tools_menu.append(_("Comparer des fichiers..."), "win.compare-files");
            tools_menu.append(_("Extensions..."), "win.extensions");

            // Menu Aide - MODIFICATION ICI
            var help_menu = new GLib.Menu();
            // Retirer la ligne "Préférences" d'ici
            help_menu.append(_("Documentation"), "win.documentation");
            help_menu.append(_("À propos"), "win.about");

            // Ajouter tous les menus à la structure principale
            menu.append_submenu(_("Fichier"), file_menu);
            menu.append_submenu(_("Édition"), edit_menu);
            menu.append_submenu(_("Affichage"), view_menu);
            menu.append_submenu(_("Outils"), tools_menu);
            menu.append_submenu(_("Aide"), help_menu);

            return menu;
        }

        /**
         * Connecte les signaux des différentes vues
         */
        private void connect_signals() {
            // Connection des signaux de l'explorateur

            // Sauvegarder l'état de la fenêtre lors de sa fermeture
            this.close_request.connect(() => {
                print("MainWindow: Demande de fermeture reçue (via close_request).\n");
                save_window_state();

                // Sauvegarder les filtres d'extension (si explorateur intégré)
                if (explorer_view != null) {
                    explorer_view.save_selected_extensions();
                }

                // Appeler la méthode de finalisation de l'application (qui sauvegarde le mode, les favoris, etc.)
                controller.finalize_app();

                // --- Fermer TOUTES les autres fenêtres de l'application ---
                var app = this.get_application();
                if (app != null) {
                    unowned var windows = app.get_windows();
                    foreach (var window in windows) {
                        if (window != this) {
                            print("MainWindow: Demande de fermeture de la fenêtre fille: %s\n", window.get_title() ?? "Sans titre");
                            window.close();
                        }
                    }

                    // AJOUT: Appeler explicitement quit() pour terminer l'application
                    print("MainWindow: Appel explicite de application.quit() depuis close_request.\n");
                    app.quit();

                } // Fin if (app != null)

                // Retourner true indique qu'on a géré la fermeture et qu'il ne faut pas
                // exécuter le handler par défaut (qui est de toute façon redondant si on appelle quit()).
                return true;
            }); // Fin du handler close_request

            // Assurer que la zone de communication reste visible avec une taille minimale
            editor_comm_paned.notify["position"].connect(() => {
                // Obtenir la hauteur actuelle de la fenêtre
                int width, height;
                this.get_default_size(out width, out height);

                // Calculer la taille minimale pour la zone de communication
                int min_comm_height = 150;
                int max_editor_height = height - min_comm_height;

                // Si la position actuelle est trop basse, ajuster
                if (editor_comm_paned.get_position() > max_editor_height) {
                    editor_comm_paned.set_position(max_editor_height);
                }
            });

            // Assurer que la zone de communication reste visible avec une taille minimale
            main_paned.notify["position"].connect(() => {
                // Obtenir la hauteur actuelle de la fenêtre
                int width, height;
                this.get_default_size(out width, out height);

                // Calculer la taille minimale pour la zone de communication
                int min_comm_height = 150;
                int max_top_height = height - min_comm_height;

                // Si la position actuelle est trop basse, ajuster
                if (main_paned.get_position() > max_top_height) {
                    main_paned.set_position(max_top_height);
                }
            });

            // TODO: Ajouter d'autres connexions de signaux au besoin
        }

        /**
         * Gestionnaire pour l'affichage/masquage de la zone de communication
         */
        private void on_communication_toggle(ToggleButton button) {
            if (button.active) {
                communication_view.show();
            } else {
                communication_view.hide();
            }
        }

        /**
         * Gère l'affichage/masquage de l'explorateur INTÉGRÉ.
         * Appelée par le ApplicationController.
         */
        public void set_integrated_explorer_visible(bool show) {
            print("TRACE: set_integrated_explorer_visible(show=%s) - use_detached_explorer=%s, explorer_view=%p, top_paned=%p\n",
                  show ? "true" : "false", use_detached_explorer ? "true" : "false", explorer_view, top_paned);

            if (use_detached_explorer || explorer_view == null || top_paned == null) {
                print("TRACE: set_integrated_explorer_visible - IGNORE (mode détaché ou vues nulles)\n");
                return; // Ne rien faire en mode détaché ou si les vues n'existent pas
            }

            if (show) {
                top_paned.set_start_child(explorer_view);
            } else {
                top_paned.set_start_child(null);
            }
        }

        /**
         * Permet au contrôleur de mettre à jour l'état du bouton (utile en mode détaché).
         */
        public void update_explorer_button_state(bool active) {
            print("TRACE: update_explorer_button_state(%s) - explorer_button=%p\n", active ? "true" : "false", explorer_button);
            if (explorer_button != null) {
                explorer_button.set_active(active);
            }
        }

        /**
         * Détermine s'il faut demander une confirmation avant de quitter
         */
        private bool should_confirm_quit() {
            // Parcourir tous les onglets pour vérifier s'il y a des modifications non sauvegardées
            foreach (var editor in editor_tabs) {
                if (editor.has_unsaved_changes()) {
                    // Afficher une boîte de dialogue de confirmation
                    var dialog = new Adw.MessageDialog(this,
                        _("Modifications non sauvegardées"),
                        _("Certains documents ont des modifications non sauvegardées. Voulez-vous vraiment quitter?")
                    );

                    dialog.add_response("cancel", _("Annuler"));
                    dialog.add_response("save_quit", _("Sauvegarder et quitter"));
                    dialog.add_response("quit", _("Quitter sans sauvegarder"));

                    dialog.set_response_appearance("quit", Adw.ResponseAppearance.DESTRUCTIVE);
                    dialog.set_response_appearance("save_quit", Adw.ResponseAppearance.SUGGESTED);
                    dialog.set_default_response("cancel");

                    dialog.response.connect((response) => {
                        if (response == "save_quit") {
                            // Sauvegarder tous les onglets modifiés
                            save_all_documents();
                            this.application.quit();
                        } else if (response == "quit") {
                            this.application.quit();
                        }
                        // "cancel" ne fait rien
                    });

                    dialog.present();
                    return true; // Indique qu'on a pris en charge la confirmation
                }
            }
            return false; // Pas besoin de confirmation
        }

        private void save_all_documents() {
            foreach (var editor in editor_tabs) {
                if (editor.has_unsaved_changes()) {
                    editor.save_document();
                }
            }
        }

        // Méthode pour gérer la fermeture de la fenêtre
        private bool on_close_request() {
            print("MainWindow: Demande de fermeture reçue (via close_request).\n");

            // Sauvegarder l'état de la fenêtre
            save_window_state();

            // Vérifier s'il y a des modifications non sauvegardées
            if (should_confirm_quit()) {
                return true; // On ne ferme pas directement, c'est géré par la boîte de dialogue
            }

            // Pas de modifications non sauvegardées, on peut quitter
            print("MainWindow: Appel explicite de application.quit() depuis close_request.\n");
            this.application.quit();
            return true;
        }

        /**
         * Sauvegarde l'état de la fenêtre avant de quitter
         */
        private void save_window_state() {
            // Récupérer la taille actuelle de la fenêtre
            int width, height;
            this.get_default_size(out width, out height);

            // Récupérer la position des séparateurs
            var main_position = top_paned.get_position();  // Position du séparateur explorateur/éditeur
            var editor_comm_position = main_paned.get_position();  // Position du séparateur zones supérieures/communication

            print("Sauvegarde des dimensions - Fenêtre: %dx%d, Séparateurs: %d, %d\n",
                  width, height, main_position, editor_comm_position);

            // Sauvegarder dans le fichier de configuration
            var config = controller.get_config_manager();
            config.set_integer("Window", "width", width);
            config.set_integer("Window", "height", height);
            config.set_integer("Window", "main_paned_position", main_position);
            config.set_integer("Window", "editor_comm_paned_position", editor_comm_position);
            config.save();
        }

        /**
         * Restaure l'état de la fenêtre depuis la configuration
         */
        private void restore_window_state() {
            print("TRACE: restore_window_state() - use_detached_explorer=%s\n", use_detached_explorer ? "OUI" : "NON");
            var config = controller.get_config_manager();

            // Restaurer la taille de la fenêtre
            int width = config.get_integer("Window", "width", 800);
            int height = config.get_integer("Window", "height", 600);

            // S'assurer que les dimensions sont raisonnables
            width = int.max(width, 600);  // Largeur minimale de 600px
            height = int.max(height, 450); // Hauteur minimale de 450px

            print("Restauration des dimensions - Fenêtre: %dx%d\n", width, height);
            this.set_default_size(width, height);

            // FORCER l'affichage de l'explorateur au démarrage
            bool show_explorer = true;

            // CORRECTION: Utiliser un Timeout pour éviter les interactions avec le mode détaché/intégré
            Timeout.add(50, () => {
                print("TRACE: restore_window_state() - Timeout - use_detached_explorer=%s, controller.is_using_detached_explorer()=%s\n",
                      use_detached_explorer ? "OUI" : "NON",
                      controller.is_using_detached_explorer() ? "OUI" : "NON");
                // Ne manipuler la visibilité via le contrôleur que si on est dans le bon mode
                // Cette condition est cruciale pour empêcher la recréation de l'explorateur intégré
                if ((use_detached_explorer && controller.is_using_detached_explorer()) ||
                    (!use_detached_explorer && !controller.is_using_detached_explorer())) {
                    print("TRACE: restore_window_state() - Appel controller.toggle_explorer_visibility(%s)\n", show_explorer ? "true" : "false");
                    controller.toggle_explorer_visibility(show_explorer);
                } else {
                    print("MainWindow: ATTENTION - Incohérence entre le mode local (%s) et le mode du contrôleur (%s)!\n",
                          use_detached_explorer ? "détaché" : "intégré",
                          controller.is_using_detached_explorer() ? "détaché" : "intégré");
                }
                return false; // Exécuter une seule fois
            });

            // Mettre à jour l'état du bouton explorer
            update_explorer_button_state(show_explorer);

            // Restaurer la position des séparateurs (SEULEMENT si en mode intégré)
            if (!use_detached_explorer) {
                int main_position = controller.get_config_manager().get_integer("Window", "main_paned_position", 280);
                int editor_comm_position = controller.get_config_manager().get_integer("Window", "editor_comm_paned_position", 500);

                // Utiliser Timeout pour s'assurer que les widgets sont prêts
                Timeout.add(150, () => {
                    if (main_paned != null) main_paned.set_position(editor_comm_position);
                    if (top_paned != null) top_paned.set_position(main_position);
                    return false; // Exécuter une seule fois
                });
            } else {
                // En mode détaché, restaurer seulement éditeur/comm
                int editor_comm_position = controller.get_config_manager().get_integer("Window", "editor_comm_paned_position", 500);
                Timeout.add(150, () => {
                    if (main_paned != null) main_paned.set_position(editor_comm_position);
                    return false;
                });
            }
        }

        // Supprime ou neutralise complètement la méthode open_file
        public void open_file(string path) {
            // Ne rien faire ici : l'ouverture de fichier passe par le flux pivot via le signal file_selected
            // Cette méthode est conservée uniquement pour compatibilité éventuelle avec d'autres modules.
        }

        // Méthode pour ouvrir un document dans un onglet
        public void open_document_in_tab(IntaText.Document.PivotDocument doc, string file_path) {
            try {
                // Vérifier d'abord si on peut réutiliser l'onglet actuel
                int current_page = editor_notebook.get_current_page();
                bool is_empty_first_tab = false;

                // Vérifier si l'onglet actuel est vide
                if (current_page >= 0 && current_page < editor_tabs.size) {
                    var current_editor = editor_tabs[current_page];
                    is_empty_first_tab = (current_editor.current_document == null);
                }

                if (is_empty_first_tab) {
                    // Réutiliser l'onglet actuel qui est vide
                    var editor = editor_tabs[current_page];
                    editor.load_document(doc);

                    // Mettre à jour le label de l'onglet
                    var tab_box = new Box(Orientation.HORIZONTAL, 6);
                    var label = new Label(Path.get_basename(file_path));
                    var close_button = new Button.from_icon_name("window-close-symbolic");
                    close_button.add_css_class("flat");
                    close_button.add_css_class("circular");
                    close_button.set_tooltip_text(_("Fermer"));
                    close_button.set_valign(Align.CENTER);
                    tab_box.append(label);
                    tab_box.append(close_button);
                    tab_box.show();

                    // Mettre à jour le libellé de l'onglet existant
                    editor_notebook.set_tab_label(editor_notebook.get_nth_page(current_page), tab_box);

                    // S'assurer que l'onglet est réordonnable
                    editor_notebook.set_tab_reorderable(editor, true);

                    // Connecter le signal du bouton de fermeture
                    close_button.clicked.connect(() => {
                        close_tab(editor);
                    });
                } else {
                    // Créer un nouvel onglet (code existant)
                    var editor = new EditorView(controller);
                    editor.load_document(doc);

                    // Créer un widget personnalisé pour l'onglet avec bouton de fermeture
                    var tab_box = new Box(Orientation.HORIZONTAL, 6);
                    var label = new Label(Path.get_basename(file_path));
                    var close_button = new Button.from_icon_name("window-close-symbolic");
                    close_button.add_css_class("flat");
                    close_button.add_css_class("circular");
                    close_button.set_tooltip_text(_("Fermer"));
                    close_button.set_valign(Align.CENTER);
                    tab_box.append(label);
                    tab_box.append(close_button);
                    tab_box.show();

                    // Ajouter à la liste et au notebook
                    editor_tabs.add(editor);
                    int page_num = editor_notebook.append_page(editor, tab_box);
                    editor_notebook.set_current_page(page_num);

                    // Activer les fonctionnalités avancées des onglets
                    editor_notebook.set_tab_reorderable(editor, true);

                    // Connecter le signal du bouton de fermeture
                    close_button.clicked.connect(() => {
                        close_tab(editor);
                    });
                }

                // Si le document vient de l'explorateur, le marquer comme tel
                if (file_path.has_suffix(".md") || file_path.has_suffix(".txt") ||
                    file_path.has_suffix(".pivot") || file_path.has_suffix(".html")) {
                    editor.mark_as_loaded_from_explorer();
                }

                // Mettre à jour l'apparence du tab
                var page_num = editor_notebook.page_num(editor);
                var tab_label = editor_notebook.get_tab_label(editor);
                update_tab_appearance(editor, tab_label);
                show_toast("Chargement réussi");
            } catch (Error e) {
                show_toast("Erreur lors du chargement : " + e.message, 4);
            }
        }

        // Méthode pour mettre à jour l'apparence d'un onglet
        private void update_tab_appearance(EditorView editor, Gtk.Widget tab_label) {
            if (tab_label is Box) {
                var box = (Box)tab_label;
                var label = box.get_first_child();

                while (label != null && !(label is Label)) {
                    label = label.get_next_sibling();
                }

                if (label is Label) {
                    var text_label = (Label)label;

                    // Premier onglet vide et non modifié
                    if (editor_tabs.size == 1 && editor == editor_tabs[0] &&
                        editor.current_document == null && !editor.has_unsaved_changes()) {
                        text_label.add_css_class("tab-label-black");
                        text_label.remove_css_class("tab-label-green");
                        text_label.remove_css_class("tab-label-yellow");
                    }
                    // Onglet sauvegardé ou chargé depuis l'explorateur
                    else if (!editor.has_unsaved_changes()) {
                        text_label.add_css_class("tab-label-green");
                        text_label.remove_css_class("tab-label-yellow");
                        text_label.remove_css_class("tab-label-black");
                    }
                    // Onglet modifié
                    else {
                        text_label.add_css_class("tab-label-yellow");
                        text_label.remove_css_class("tab-label-green");
                        text_label.remove_css_class("tab-label-black");
                    }
                }
            }
        }

        // Ajouter cette nouvelle méthode pour gérer la fermeture des onglets
        public void close_tab(EditorView editor_to_close) { // Renamed parameter
            // Trouver l'index de cet éditeur dans la liste
            int editor_index = -1; // Renamed variable
            for (int i = 0; i < editor_tabs.size; i++) {
                if (editor_tabs[i] == editor_to_close) {
                    editor_index = i;
                    break;
                }
            }

            if (editor_index >= 0) {
                // Si l'éditeur a des modifications non sauvegardées, demander confirmation
                if (editor_to_close.has_unsaved_changes()) { // Use renamed variable
                    var dialog = new Gtk.MessageDialog(
                        this,
                        DialogFlags.MODAL,
                        MessageType.QUESTION,
                        ButtonsType.NONE,
                        _("Ce document contient des modifications non sauvegardées. Souhaitez-vous l'enregistrer avant de fermer?")
                    );

                    dialog.add_button(_("Abandonner les modifications"), 0);
                    dialog.add_button(_("Annuler"), 1);
                    dialog.add_button(_("Enregistrer"), 2);

                    // Capture local copies for the closure
                    var captured_editor = editor_to_close;
                    var captured_index = editor_index;

                    dialog.response.connect((id) => {
                        dialog.destroy();
                        if (id == 0) {
                            // Abandonner les modifications
                            remove_tab(captured_index); // Use captured index
                        } else if (id == 2) {
                            // Enregistrer, puis fermer
                            if (captured_editor.save_document()) { // Use captured editor
                                remove_tab(captured_index); // Use captured index
                            }
                        }
                        // Si id == 1 (Annuler), ne rien faire
                    });

                    dialog.show();
                } else {
                    // Pas de modifications, fermer directement
                    remove_tab(editor_index); // Use original index here
                }
            }
        }

        // Méthode pour supprimer physiquement l'onglet
        private void remove_tab(int index) {
            if (index >= 0 && index < editor_tabs.size) {
                var editor = editor_tabs[index];
                editor_tabs.remove_at(index);
                editor_notebook.remove_page(index);

                // Si c'était le dernier onglet, créer un onglet vide
                if (editor_tabs.size == 0) {
                    var new_editor = new EditorView(controller);
                    editor_tabs.add(new_editor);
                    editor_notebook.append_page(new_editor, new Label(_("Nouveau document")));
                }
            }
        }

        // Méthode utilitaire pour afficher un toast
        private void show_toast(string message, int timeout = 2) {
            var toast = new Adw.Toast(message);
            toast.set_timeout(timeout);
            var overlay = this.find_descendant_of_type<Adw.ToastOverlay>();
            if (overlay != null) {
                overlay.add_toast(toast);
            }
        }

        // Méthode pour sauvegarder le document actuel
        private void save_current_document() {
            int current_page = editor_notebook.get_current_page();
            if (current_page >= 0 && current_page < editor_tabs.size) {
                var editor = editor_tabs[current_page];
                try {
                    if (editor.save_document()) {
                        show_toast("Document sauvegardé");
                    } else {
                        show_toast("Erreur lors de la sauvegarde", 4);
                    }
                } catch (Error e) {
                    show_toast("Erreur lors de la sauvegarde : " + e.message, 4);
                }
            }
        }

        /**
         * Sauvegarde le document actuel sous un nouveau nom
         */
        private void save_current_document_as() {
            int current_page = editor_notebook.get_current_page();
            if (current_page >= 0 && current_page < editor_tabs.size) {
                var editor = editor_tabs[current_page];
                editor.save_document_as();
            }
        }

        public void apply_editor_style_to_all_tabs(int size, string family, string color) {
            foreach (var editor in editor_tabs) {
                editor.set_editor_style(size, family, color);
            }
        }
    }

    /**
     * Dialogue de recherche avancée
     */
    public class SearchDialog : Adw.Window {
        private ApplicationController controller;

        public SearchDialog(Adw.Window parent, ApplicationController controller) {
            Object(
                transient_for: parent,
                title: _("Recherche avancée"),
                modal: true,
                width_request: 500,
                height_request: 400
            );

            this.controller = controller;

            // Créer l'interface du dialogue de recherche
            // ...
        }
    }
}
